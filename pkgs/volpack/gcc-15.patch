FIXME: This patch is incomplete!  It fails on M4 autogenerated files!
       So it is deactivated but left here for further reference
Author: Andreas Tille <tille@debian.org>
Last-Update: 2025-10-06
Bug-Debian: https://bugs.debian.org/1098072
Description: Make sure code builds with gcc-15

--- a/vp_context.c
+++ b/vp_context.c
@@ -51,11 +51,11 @@ int vpRunFragmentCount = 0;
  * Initialize the fields of a context that have defaults.
  */
 
+#include <unistd.h>
+
 static void
-InitContext(vpc)
-vpContext *vpc;
+InitContext(vpContext *vpc)
 {
-    extern int read(), write();
     int m, l;
 
     vpc->xlen = 0;
@@ -176,8 +176,7 @@ vpCreateContext()
  */
 
 void
-vpDestroyContext(vpc)
-vpContext *vpc;
+vpDestroyContext(vpContext *vpc)
 {
     VPResizeDepthCueTable(vpc, 0, 0);
     VPResizeRenderBuffers(vpc, 0, 0, 0);
@@ -199,9 +198,7 @@ vpContext *vpc;
  */
 
 vpResult
-vpSetVolumeSize(vpc, xlen, ylen, zlen)
-vpContext *vpc;
-int xlen, ylen, zlen;
+vpSetVolumeSize(vpContext *vpc, int xlen, int ylen, int zlen)
 {
     vpc->xlen = xlen;
     vpc->ylen = ylen;
@@ -219,13 +216,12 @@ int xlen, ylen, zlen;
  */
 
 vpResult
-vpSetVoxelSize(vpc, bytes_per_voxel, num_voxel_fields, num_shade_fields,
-	       num_clsfy_fields)
-vpContext *vpc;
-int bytes_per_voxel;
-int num_voxel_fields;
-int num_shade_fields;
-int num_clsfy_fields;
+vpSetVoxelSize(
+	vpContext *vpc,
+	int bytes_per_voxel,
+	int num_voxel_fields,
+	int num_shade_fields,
+	int num_clsfy_fields)
 {
     if (num_voxel_fields >= VP_MAX_FIELDS)
 	return(VPSetError(vpc, VPERROR_LIMIT_EXCEEDED));
@@ -249,12 +245,12 @@ int num_clsfy_fields;
  */
 
 vpResult
-vpSetVoxelField(vpc, field_num, field_size, field_offset, field_max)
-vpContext *vpc;
-int field_num;
-int field_size;
-int field_offset;
-int field_max;
+vpSetVoxelField(
+	vpContext *vpc,
+	int field_num,
+	int field_size,
+	int field_offset,
+	int field_max)
 {
     if (field_num < 0 || field_num >= vpc->num_voxel_fields)
 	return(VPSetError(vpc, VPERROR_BAD_VALUE));
@@ -277,11 +273,11 @@ int field_max;
  */
 
 vpResult
-vpSetRawVoxels(vpc, raw_voxels, raw_voxels_size, xstride, ystride, zstride)
-vpContext *vpc;
-int xstride, ystride, zstride;
-void *raw_voxels;
-int raw_voxels_size;
+vpSetRawVoxels(
+	vpContext *vpc,
+	int xstride, int ystride, int zstride,
+	void *raw_voxels,
+	int raw_voxels_size)
 {
     vpc->raw_voxels = raw_voxels;
     vpc->raw_voxels_size = raw_voxels_size;
@@ -302,12 +298,12 @@ int raw_voxels_size;
  */
 
 vpResult
-vpSetClassifierTable(vpc, param_num, param_field, table, table_size)
-vpContext *vpc;
-int param_num;
-int param_field;
-float *table;
-int table_size;
+vpSetClassifierTable(
+	vpContext *vpc,
+	int param_num,
+	int param_field,
+	float *table,
+	int table_size)
 {
     if (param_num < 0 || param_num >= vpc->num_clsfy_params)
 	return(VPSetError(vpc, VPERROR_BAD_VALUE));
@@ -326,18 +322,16 @@ int table_size;
  */
 
 vpResult
-vpSetLookupShader(vpc, color_channels, num_materials,
-		  color_field, color_table, color_table_size,
-		  weight_field, weight_table, weight_table_size)
-vpContext *vpc;
-int color_channels;
-int num_materials;
-int color_field;
-float *color_table;
-int color_table_size;
-int weight_field;
-float *weight_table;
-int weight_table_size;
+vpSetLookupShader(
+	vpContext *vpc,
+	int color_channels,
+	int num_materials,
+	int color_field,
+	float *color_table,
+	int color_table_size,
+	int weight_field,
+	float *weight_table,
+	int weight_table_size)
 {
     if (color_channels != 1 && color_channels != 3)
 	return(VPSetError(vpc, VPERROR_BAD_VALUE));
@@ -370,21 +364,18 @@ int weight_table_size;
  */
 
 vpResult
-vpSetShadowLookupShader(vpc, color_channels, num_materials,
-			color_field, color_table, color_table_size,
-			weight_field, weight_table, weight_table_size,
-			shadow_table, shadow_table_size)
-vpContext *vpc;
-int color_channels;
-int num_materials;
-int color_field;
-float *color_table;
-int color_table_size;
-int weight_field;
-float *weight_table;
-int weight_table_size;
-float *shadow_table;
-int shadow_table_size;
+vpSetShadowLookupShader(
+	vpContext *vpc,
+	int color_channels,
+	int num_materials,
+	int color_field,
+	float *color_table,
+	int color_table_size,
+	int weight_field,
+	float *weight_table,
+	int weight_table_size,
+	float *shadow_table,
+	int shadow_table_size)
 {
     if (color_channels != 1 && color_channels != 3)
 	return(VPSetError(vpc, VPERROR_BAD_VALUE));
@@ -421,12 +412,12 @@ int shadow_table_size;
  */
 
 vpResult
-vpSetMaterial(vpc, material, property, surface_side, r, g, b)
-vpContext *vpc;
-int material;
-int property;
-int surface_side;
-double r, g, b;
+vpSetMaterial(
+	vpContext *vpc,
+	int material,
+	int property,
+	int surface_side,
+	double r, double g, double b)
 {
     material -= VP_MATERIAL0;
     if (material < 0 || material >= vpc->num_materials)
@@ -493,11 +484,11 @@ double r, g, b;
  */
 
 vpResult
-vpSetLight(vpc, light_num, property, n0, n1, n2)
-vpContext *vpc;
-int light_num;
-int property;
-double n0, n1, n2;
+vpSetLight(
+	vpContext *vpc,
+	int light_num,
+	int property,
+	double n0, double n1, double n2)
 {
     vpVector4 v1, v2;
 
@@ -535,10 +526,7 @@ double n0, n1, n2;
  */
 
 vpResult
-vpEnable(vpc, option, value)
-vpContext *vpc;
-int option;
-int value;
+vpEnable(vpContext *vpc, int option, int value)
 {
     switch (option) {
     case VP_LIGHT0:
@@ -615,10 +603,7 @@ int value;
  */
 
 vpResult
-vpSetDepthCueing(vpc, front_factor, density)
-vpContext *vpc;
-double front_factor;
-double density;
+vpSetDepthCueing(vpContext *vpc, double front_factor, double density)
 {
     if (front_factor <= 0.)
 	return(VPSetError(vpc, VPERROR_BAD_VALUE));
@@ -636,9 +621,7 @@ double density;
  */
 
 vpResult
-vpCurrentMatrix(vpc, option)
-vpContext *vpc;
-int option;
+vpCurrentMatrix(vpContext *vpc, int option)
 {
     switch (option) {
     case VP_MODEL:
@@ -659,8 +642,7 @@ int option;
  */
 
 vpResult
-vpIdentityMatrix(vpc)
-vpContext *vpc;
+vpIdentityMatrix(vpContext *vpc)
 {
     vpIdentity4(vpc->transforms[vpc->current_matrix]);
     vpc->factored_view_ready = 0;
@@ -674,9 +656,7 @@ vpContext *vpc;
  */
 
 vpResult
-vpSetMatrix(vpc, matrix)
-vpContext *vpc;
-vpMatrix4 matrix;
+vpSetMatrix(vpContext *vpc, vpMatrix4 matrix)
 {
     bcopy(matrix, vpc->transforms[vpc->current_matrix], sizeof(vpMatrix4));
     vpc->factored_view_ready = 0;
@@ -690,10 +670,7 @@ vpMatrix4 matrix;
  */
 
 vpResult
-vpGetMatrix(vpc, matrix_code, matrix)
-vpContext *vpc;
-int matrix_code;
-vpMatrix4 matrix;
+vpGetMatrix(vpContext *vpc, int matrix_code, vpMatrix4 matrix)
 {
     switch (matrix_code) {
     case VP_MODEL:
@@ -717,9 +694,7 @@ vpMatrix4 matrix;
  */
 
 vpResult
-vpMultMatrix(vpc, matrix)
-vpContext *vpc;
-vpMatrix4 matrix;
+vpMultMatrix(vpContext *vpc, vpMatrix4 matrix)
 {
     vpMatrix4 tmp;
 
@@ -739,9 +714,7 @@ vpMatrix4 matrix;
  */
 
 vpResult
-vpTranslate(vpc, tx, ty, tz)
-vpContext *vpc;
-double tx, ty, tz;
+vpTranslate(vpContext *vpc, double tx, double ty, double tz)
 {
     vpMatrix4 t, tmp;
 
@@ -762,10 +735,7 @@ double tx, ty, tz;
  */
 
 vpResult
-vpRotate(vpc, axis, degrees)
-vpContext *vpc;
-int axis;
-double degrees;
+vpRotate(vpContext *vpc, int axis, double degrees)
 {
     vpMatrix4 r, tmp;
 
@@ -788,9 +758,7 @@ double degrees;
  */
 
 vpResult
-vpScale(vpc, sx, sy, sz)
-vpContext *vpc;
-double sx, sy, sz;
+vpScale(vpContext *vpc, double sx, double sy, double sz)
 {
     vpMatrix4 s, tmp;
 
@@ -812,10 +780,10 @@ double sx, sy, sz;
  */
 
 vpResult
-vpWindow(vpc, type, left, right, bottom, top, near, far)
-vpContext *vpc;
-int type;
-double left, right, bottom, top, near, far;
+vpWindow(
+	vpContext *vpc,
+	int type,
+	double left, double right, double bottom, double top, double near, double far)
 {
     vpMatrix4 projectm, tmp;
 
@@ -865,21 +833,19 @@ double left, right, bottom, top, near, f
  */
 
 vpResult
-vpWindowPHIGS(vpc, vrp, vpn, vup, prp, viewport_umin, viewport_umax,
-	      viewport_vmin, viewport_vmax, viewport_front, viewport_back,
-	      projection_type)
-vpContext *vpc;
-vpVector3 vrp;
-vpVector3 vpn;
-vpVector3 vup;
-vpVector3 prp;
-double viewport_umin;
-double viewport_umax;
-double viewport_vmin;
-double viewport_vmax;
-double viewport_front;
-double viewport_back;
-int projection_type;
+vpWindowPHIGS(
+	vpContext *vpc,
+	vpVector3 vrp,
+	vpVector3 vpn,
+	vpVector3 vup,
+	vpVector3 prp,
+	double viewport_umin,
+	double viewport_umax,
+	double viewport_vmin,
+	double viewport_vmax,
+	double viewport_front,
+	double viewport_back,
+	int projection_type)
 {
     vpMatrix4 m1, m2, m3;
     double cw_x, cw_y;	/* center of window */
@@ -975,12 +941,12 @@ int projection_type;
  */
 
 vpResult
-vpSetImage(vpc, image, width, height, bytes_per_scan, pixel_type)
-vpContext *vpc;
-unsigned char *image;
-int width, height;
-int bytes_per_scan;
-int pixel_type;
+vpSetImage(
+	vpContext *vpc,
+	unsigned char *image,
+	int width, int height,
+	int bytes_per_scan,
+	int pixel_type)
 {
     int bytes_per_pixel;
 
@@ -1026,10 +992,7 @@ int pixel_type;
  */
 
 vpResult
-vpSeti(vpc, option, value)
-vpContext *vpc;
-int option;
-int value;
+vpSeti(vpContext *vpc, int option, int value)
 {
     switch (option) {
     case VP_CONCAT_MODE:
@@ -1108,10 +1071,7 @@ int value;
  */
 
 vpResult
-vpSetd(vpc, option, value)
-vpContext *vpc;
-int option;
-double value;
+vpSetd(vpContext *vpc, int option, double value)
 {
     switch (option) {
     case VP_DEPTH_CUE_QUANTIZATION:
@@ -1143,10 +1103,7 @@ double value;
  */
 
 vpResult
-vpMinMaxOctreeThreshold(vpc, param, range)
-vpContext *vpc;
-int param;
-int range;
+vpMinMaxOctreeThreshold(vpContext *vpc, int param, int range)
 {
     if (param >= vpc->num_clsfy_params)
 	return(VPSetError(vpc, VPERROR_BAD_VALUE));
@@ -1161,13 +1118,8 @@ int range;
  */
 
 vpResult
-vpSetCallback(vpc, option, func)
-vpContext *vpc;
-int option;
-void *func;
+vpSetCallback(vpContext *vpc, int option, void *func)
 {
-    extern int read(), write();
-
     switch (option) {
     case VP_LOG_ALLOC_FUNC:
 	vpc->log_alloc_func = func;
@@ -1224,9 +1176,7 @@ void *func;
  */
 
 vpResult
-vpSetClientData(vpc, client_data)
-vpContext *vpc;
-void *client_data;
+vpSetClientData(vpContext *vpc, void *client_data)
 {
     vpc->client_data = client_data;
     return(VP_OK);
@@ -1239,10 +1189,7 @@ void *client_data;
  */
 
 vpResult
-vpSetDebug(vpc, flag, value)
-vpContext *vpc;
-int flag;
-int value;
+vpSetDebug(vpContext *vpc, int flag, int value)
 {
     if (flag < 0 || flag >= VPDEBUG_COUNT)
 	return(VPSetError(vpc, VPERROR_BAD_OPTION));
@@ -1259,9 +1206,8 @@ int value;
  */
 
 vpResult
-vpTracePixel(vpc, trace_u, trace_v)
-vpContext *vpc;
-int trace_u, trace_v;	/* pixel coordinates */
+vpTracePixel(vpContext *vpc, int trace_u, int trace_v)
+ /* int trace_u, trace_v;	pixel coordinates */
 {
 #ifdef DEBUG
     vpc->trace_u = trace_u;
@@ -1277,10 +1223,7 @@ int trace_u, trace_v;	/* pixel coordinat
  */
 
 vpResult
-vpGeti(vpc, option, iptr)
-vpContext *vpc;
-int option;
-int *iptr;
+vpGeti(vpContext *vpc, int option, int *iptr)
 {
     int c;
     int retcode;
@@ -1528,10 +1471,7 @@ int *iptr;
  */
 
 vpResult
-vpGetd(vpc, option, dptr)
-vpContext *vpc;
-int option;
-double *dptr;
+vpGetd(vpContext *vpc, int option, double *dptr)
 {
     int c;
 
@@ -1564,10 +1504,7 @@ double *dptr;
  */
 
 vpResult
-vpGetp(vpc, option, pptr)
-vpContext *vpc;
-int option;
-void **pptr;
+vpGetp(vpContext *vpc, int option, void **pptr)
 {
     int c;
 
@@ -1628,12 +1565,12 @@ void **pptr;
  */
 
 vpResult
-vpGetMaterial(vpc, material, property, surface_side, r, g, b)
-vpContext *vpc;
-int material;
-int property;
-int surface_side;
-double *r, *g, *b;
+vpGetMaterial(
+	vpContext *vpc,
+	int material,
+	int property,
+	int surface_side,
+	double *r, double *g, double *b)
 {
     material -= VP_MATERIAL0;
     if (material < 0 || material >= vpc->num_materials)
@@ -1693,11 +1630,11 @@ double *r, *g, *b;
  */
 
 vpResult
-vpGetLight(vpc, light_num, property, n0, n1, n2)
-vpContext *vpc;
-int light_num;
-int property;
-double *n0, *n1, *n2;
+vpGetLight(
+	vpContext *vpc,
+	int light_num,
+	int property,
+	double *n0, double *n1, double *n2)
 {
     light_num -= VP_LIGHT0;
     if (light_num < 0 || light_num >= VP_MAX_LIGHTS)
@@ -1726,15 +1663,15 @@ double *n0, *n1, *n2;
  */
 
 vpResult
-vpGetImage(vpc, image, width, height, scan_bytes, pixel_type, image_type)
-vpContext *vpc;		/* context */
-void *image;		/* buffer for storing result */
-int width;		/* expected width of image in buffer */
-int height;		/* expected height of image in buffer */
-int scan_bytes;		/* bytes per scanline in buffer */
-int pixel_type;		/* type of pixel to store in buffer */
-int image_type;		/* rendering buffer to extract from
-			   (VP_IMAGE_BUFFER or VP_SHADOW_BUFFER) */
+vpGetImage(
+	vpContext *vpc,		/* context */
+	void *image,		/* buffer for storing result */
+	int width,		/* expected width of image in buffer */
+	int height,		/* expected height of image in buffer */
+	int scan_bytes,		/* bytes per scanline in buffer */
+	int pixel_type,		/* type of pixel to store in buffer */
+	int image_type)		/* rendering buffer to extract from
+				   (VP_IMAGE_BUFFER or VP_SHADOW_BUFFER) */
 {
     int x, y;
     unsigned char *dst_ptr;
@@ -2027,10 +1964,7 @@ int image_type;		/* rendering buffer to
  */
 
 vpResult
-vpGetTimer(vpc, option, iptr)
-vpContext *vpc;
-int option;
-int *iptr;
+vpGetTimer(vpContext *vpc, int option, int *iptr)
 {
     if (option < 0 || option >= VPTIMER_COUNT)
 	return(VPSetError(vpc, VPERROR_BAD_OPTION));
@@ -2049,9 +1983,7 @@ int *iptr;
  */
 
 vpResult
-vpClearTimer(vpc, option)
-vpContext *vpc;
-int option;
+vpClearTimer(vpContext *vpc, int option)
 {
     if (option < 0 || option >= VPTIMER_COUNT)
 	return(VPSetError(vpc, VPERROR_BAD_OPTION));
@@ -2072,8 +2004,7 @@ int option;
  */
 
 static void
-StartHiResTimer(vpc)
-vpContext *vpc;
+StartHiResTimer(vpContext *vpc)
 {
     volatile unsigned timer_resolution; /* resolution of timer in psec. */
     unsigned phys_addr;		/* hardware address of timer */
--- a/vp_global.h
+++ b/vp_global.h
@@ -551,9 +551,9 @@ struct _vp_context {			/* vpContext */
     int end_of_parameters;
 
     /* callback functions */
-    void (*shade_func)();		/* shade a voxel */
-    int (*write_func) ANSI_ARGS((int, void *, unsigned)); /* write to file */
-    int (*read_func) ANSI_ARGS((int, void *, unsigned));  /* read from file */
+    void (*shade_func)(void *, float *, void *);	/* shade a voxel */
+    ssize_t (*write_func)(int, const void *, size_t);	/* write to file */
+    ssize_t (*read_func)(int, void *, size_t);		/* read from file */
     void *(*mmap_func) ANSI_ARGS((int, unsigned, void *));/* memory map file */
     void (*log_alloc_func) ANSI_ARGS((void *,int,char *,int,char *,void *));
     					/* log memory allocation */
@@ -744,9 +744,12 @@ extern void		    VPDumpClassifier ANSI_A
 #endif
 
 
+typedef void (*VPCompositeFunc)(vpContext*, int, int, int, double, void*, 
+                               double, double, double, double, ...);
+
 /* vp_renderA.c */
-extern void		    VPRenderAffine ANSI_ARGS((vpContext *vpc,
-				int algorithm, void (*composite_func)()));
+extern vpResult		    VPRenderAffine ANSI_ARGS((vpContext *vpc,
+				int algorithm, VPCompositeFunc composite_func));
 
 /* vp_octree.c */
 extern void		    VPComputeSummedAreaTable ANSI_ARGS((
--- a/vp_extract.c
+++ b/vp_extract.c
@@ -466,11 +466,11 @@ int dst_zstride;
  */
 
 static void
-ShadeVoxel(vpc, voxel, x, y, z, dst)
-vpContext *vpc;		/* context */
-void *voxel;		/* voxel data */
-int x, y, z;		/* voxel coordinates */
-float *dst;		/* storage for result (1 or 3 intensities, 0-255) */
+ShadeVoxel(
+	vpContext *vpc,		/* context */
+	void *voxel,		/* voxel data */
+	int x, int y, int z,	/* voxel coordinates */
+	float *dst)		/* storage for result (1 or 3 intensities, 0-255) */
 {
     int num_materials;
     int color_channels;
@@ -487,7 +487,8 @@ float *dst;		/* storage for result (1 or
 	if (vpc->color_channels == 1)
 	    vpc->shade_func(voxel, dst, vpc->client_data);
 	else
-	    vpc->shade_func(voxel, dst, dst+1, dst+2, vpc->client_data);
+	    /* very ugly hack to deal with different definitions */
+	    ((void (*)(void *, float *, float *, float *, void *))vpc->shade_func)(voxel, dst, dst+1, dst+2, vpc->client_data);
 	return;
     } else if (vpc->shading_mode != LOOKUP_SHADER) {
 	VPBug("unknown shader type");
@@ -547,16 +548,15 @@ float *dst;		/* storage for result (1 or
  */
 
 void
-VPQuantize(src, xlen, ylen, zlen, scale, maxvalue, dst,
-	   dst_xstride, dst_ystride, dst_zstride)
-float *src;		/* floating point array */
-int xlen, ylen, zlen;	/* array dimensions */
-double scale;		/* scale to apply to each array element */
-int maxvalue;		/* clamp each array element to this value */
-unsigned char *dst;	/* store results here */
-int dst_xstride;	/* stride (in bytes) for destination array */
-int dst_ystride;
-int dst_zstride;
+VPQuantize(
+	float *src,		/* floating point array */
+	int xlen, int ylen, int zlen,	/* array dimensions */
+	double scale,		/* scale to apply to each array element */
+	int maxvalue,		/* clamp each array element to this value */
+	unsigned char *dst,	/* store results here */
+	int dst_xstride,	/* stride (in bytes) for destination array */
+	int dst_ystride,
+	int dst_zstride)
 {
     int value;
     int x, y, z;
@@ -585,17 +585,16 @@ int dst_zstride;
  */
 
 static int
-ExtractClassifiedVolume(vpc, axis, x0, y0, z0, x1, y1, z1, field, dst,
-			dst_xstride, dst_ystride, dst_zstride)
-vpContext *vpc;		/* context */
-int axis;		/* which axis to extract from */
-int x0, y0, z0;		/* origin of extracted region */
-int x1, y1, z1;		/* opposite corner of extracted region */
-int field;		/* field to extract */
-void *dst;		/* buffer to store result into */
-int dst_xstride;	/* stride (in bytes) for destination array */
-int dst_ystride;
-int dst_zstride;
+ExtractClassifiedVolume(
+	vpContext *vpc,		/* context */
+	int axis,		/* which axis to extract from */
+	int x0, int y0, int z0,	/* origin of extracted region */
+	int x1, int y1, int z1,	/* opposite corner of extracted region */
+	int field,		/* field to extract */
+	void *dst,		/* buffer to store result into */
+	int dst_xstride,	/* stride (in bytes) for destination array */
+	int dst_ystride,
+	int dst_zstride)
 {
     int i, j, k;		/* voxel coordinates in rotated object space */
     int i0, j0, k0;		/* origin of extracted region */
--- a/vp_renderR.c
+++ b/vp_renderR.c
@@ -31,44 +31,44 @@
 #include "vp_global.h"
 
 #define COMP_AR1PB_FUNC		VPCompAR1PB
-extern void VPCompAR1PB();
+extern void VPCompAR1PB(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #define COMP_AR3PB_FUNC		VPCompAR3PB
-extern void VPCompAR3PB();
+extern void VPCompAR3PB(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #ifdef COMP_AR11B
 #define COMP_AR11B_FUNC		VPCompAR11B
-extern void VPCompAR11B();
+extern void VPCompAR11B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AR11B_FUNC		VPCompAR1NB
 #endif
 
 #ifdef COMP_AR31B
 #define COMP_AR31B_FUNC		VPCompAR31B
-extern void VPCompAR31B();
+extern void VPCompAR31B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AR31B_FUNC		VPCompAR3NB
 #endif
 
 #ifdef COMP_AR12B
 #define COMP_AR12B_FUNC		VPCompAR12B
-extern void VPCompAR12B();
+extern void VPCompAR12B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AR12B_FUNC		VPCompAR1NB
 #endif
 
 #ifdef COMP_AR32B
 #define COMP_AR32B_FUNC		VPCompAR32B
-extern void VPCompAR32B();
+extern void VPCompAR32B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AR32B_FUNC		VPCompAR3NB
 #endif
 
 #define COMP_AR1NB_FUNC		VPCompAR1NB
-extern void VPCompAR1NB();
+extern void VPCompAR1NB(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #define COMP_AR3NB_FUNC		VPCompAR3NB
-extern void VPCompAR3NB();
+extern void VPCompAR3NB(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 
 #define COMP_AR1PS_FUNC		VPCompAR1PB
@@ -77,40 +77,40 @@ extern void VPCompAR3NB();
 
 #ifdef COMP_AR11S
 #define COMP_AR11S_FUNC		VPCompAR11S
-extern void VPCompAR11S();
+extern void VPCompAR11S(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AR11S_FUNC		VPCompAR1NS
 #endif
 
 #ifdef COMP_AR31S
 #define COMP_AR31S_FUNC		VPCompAR31S
-extern void VPCompAR31S();
+extern void VPCompAR31S(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AR31S_FUNC		VPCompAR3NS
 #endif
 
 #ifdef COMP_AR12S
 #define COMP_AR12S_FUNC		VPCompAR12S
-extern void VPCompAR12S();
+extern void VPCompAR12S(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AR12S_FUNC		VPCompAR1NS
 #endif
 
 #ifdef COMP_AR32S
 #define COMP_AR32S_FUNC		VPCompAR32S
-extern void VPCompAR32S();
+extern void VPCompAR32S(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AR32S_FUNC		VPCompAR3NS
 #endif
 
 #define COMP_AR1NS_FUNC		VPCompAR1NS
-extern void VPCompAR1NS();
+extern void VPCompAR1NS(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #define COMP_AR3NS_FUNC		VPCompAR3NS
-extern void VPCompAR3NS();
+extern void VPCompAR3NS(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #ifdef INDEX_VOLUME
-extern void VPCompAI11B();
+extern void VPCompAI11B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #endif
 
 #define SHADOWS_OFF		0
@@ -127,7 +127,7 @@ extern void VPCompAI11B();
 #define COLOR_RGB		1
 #define COLOR_OPTS		2
 
-static void (*AffineProcTable[SHADOW_OPTS][MATERIAL_OPTS][COLOR_OPTS])() = {
+static VPCompositeFunc AffineProcTable[SHADOW_OPTS][MATERIAL_OPTS][COLOR_OPTS] = {
     {
 	{ COMP_AR1PB_FUNC, COMP_AR3PB_FUNC },
 	{ COMP_AR11B_FUNC, COMP_AR31B_FUNC },
@@ -149,11 +149,10 @@ static void (*AffineProcTable[SHADOW_OPT
  */
 
 vpResult
-vpRenderRawVolume(vpc)
-vpContext *vpc;
+vpRenderRawVolume(vpContext *vpc)
 {
     int retcode;
-    void (*composite_func)();
+    VPCompositeFunc composite_func;
     int shadow_option, material_option, color_option;
 
     /* check for errors and initialize */
--- a/vp_renderC.c
+++ b/vp_renderC.c
@@ -31,44 +31,44 @@
 #include "vp_global.h"
 
 #define COMP_AC1PB_FUNC		VPCompAC1PB
-extern void VPCompAC1PB();
+extern void VPCompAC1PB(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #define COMP_AC3PB_FUNC		VPCompAC3PB
-extern void VPCompAC3PB();
+extern void VPCompAC3PB(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #ifdef COMP_AC11B
 #define COMP_AC11B_FUNC		VPCompAC11B
-extern void VPCompAC11B();
+extern void VPCompAC11B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AC11B_FUNC		VPCompAC1NB
 #endif
 
 #ifdef COMP_AC31B
 #define COMP_AC31B_FUNC		VPCompAC31B
-extern void VPCompAC31B();
+extern void VPCompAC31B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AC31B_FUNC		VPCompAC3NB
 #endif
 
 #ifdef COMP_AC12B
 #define COMP_AC12B_FUNC		VPCompAC12B
-extern void VPCompAC12B();
+extern void VPCompAC12B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AC12B_FUNC		VPCompAC1NB
 #endif
 
 #ifdef COMP_AC32B
 #define COMP_AC32B_FUNC		VPCompAC32B
-extern void VPCompAC32B();
+extern void VPCompAC32B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AC32B_FUNC		VPCompAC3NB
 #endif
 
 #define COMP_AC1NB_FUNC		VPCompAC1NB
-extern void VPCompAC1NB();
+extern void VPCompAC1NB(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #define COMP_AC3NB_FUNC		VPCompAC3NB
-extern void VPCompAC3NB();
+extern void VPCompAC3NB(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 
 #define COMP_AC1PS_FUNC		VPCompAC1PB
@@ -77,40 +77,40 @@ extern void VPCompAC3NB();
 
 #ifdef COMP_AC11S
 #define COMP_AC11S_FUNC		VPCompAC11S
-extern void VPCompAC11S();
+extern void VPCompAC11S(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AC11S_FUNC		VPCompAC1NS
 #endif
 
 #ifdef COMP_AC31S
 #define COMP_AC31S_FUNC		VPCompAC31S
-extern void VPCompAC31S();
+extern void VPCompAC31S(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AC31S_FUNC		VPCompAC3NS
 #endif
 
 #ifdef COMP_AC12S
 #define COMP_AC12S_FUNC		VPCompAC12S
-extern void VPCompAC12S();
+extern void VPCompAC12S(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AC12S_FUNC		VPCompAC1NS
 #endif
 
 #ifdef COMP_AC32S
 #define COMP_AC32S_FUNC		VPCompAC32S
-extern void VPCompAC32S();
+extern void VPCompAC32S(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #else
 #define COMP_AC32S_FUNC		VPCompAC3NS
 #endif
 
 #define COMP_AC1NS_FUNC		VPCompAC1NS
-extern void VPCompAC1NS();
+extern void VPCompAC1NS(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #define COMP_AC3NS_FUNC		VPCompAC3NS
-extern void VPCompAC3NS();
+extern void VPCompAC3NS(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 
 #ifdef INDEX_VOLUME
-extern void VPCompAI11B();
+extern void VPCompAI11B(vpContext*, int, int, int, double, void*, double, double, double, double, ...);
 #endif
 
 #define SHADOWS_OFF		0
@@ -127,7 +127,7 @@ extern void VPCompAI11B();
 #define COLOR_RGB		1
 #define COLOR_OPTS		2
 
-static void (*AffineProcTable[SHADOW_OPTS][MATERIAL_OPTS][COLOR_OPTS])() = {
+static VPCompositeFunc AffineProcTable[SHADOW_OPTS][MATERIAL_OPTS][COLOR_OPTS] = {
     {
 	{ COMP_AC1PB_FUNC, COMP_AC3PB_FUNC },
 	{ COMP_AC11B_FUNC, COMP_AC31B_FUNC },
@@ -150,11 +150,10 @@ static void (*AffineProcTable[SHADOW_OPT
  */
 
 vpResult
-vpRenderClassifiedVolume(vpc)
-vpContext *vpc;
+vpRenderClassifiedVolume(vpContext *vpc)
 {
     int retcode;
-    void (*composite_func)();
+    VPCompositeFunc composite_func;
     int shadow_option, material_option, color_option;
 #ifdef INDEX_VOLUME
     int have_index;
--- a/vp_renderB.c
+++ b/vp_renderB.c
@@ -61,8 +61,7 @@ static void AffineBruteForceWarp ANSI_AR
  */
 
 vpResult
-vpBruteForceRender(vpc)
-vpContext *vpc;
+vpBruteForceRender(vpContext *vpc)
 {
     int retcode;
 
@@ -95,8 +94,7 @@ vpContext *vpc;
  */
 
 static void
-AffineBruteForceRender(vpc)
-vpContext *vpc;
+AffineBruteForceRender(vpContext *vpc)
 {
     int icount;			/* voxels per voxel scanline */
     int jcount;			/* voxel scanlines per voxel slice */
@@ -274,10 +272,7 @@ vpContext *vpc;
  */
 
 static void
-ClassifySlice(vpc, slicenum, opc_slice)
-vpContext *vpc;
-int slicenum;
-float *opc_slice;
+ClassifySlice(vpContext *vpc, int slicenum, float *opc_slice)
 {
     switch (vpc->best_view_axis) {
     case VP_X_AXIS:
@@ -305,10 +300,7 @@ float *opc_slice;
  */
 
 static void
-ShadeSlice(vpc, slicenum, clr_slice)
-vpContext *vpc;
-int slicenum;
-float *clr_slice;
+ShadeSlice(vpContext *vpc, int slicenum, float *clr_slice)
 {
     int color_bytes;
 
@@ -337,12 +329,7 @@ float *clr_slice;
  */
 
 static void
-ScaleColors(scale, clr_slice, width, height, color_channels)
-double scale;
-float *clr_slice;
-int width;
-int height;
-int color_channels;
+ScaleColors(double scale, float *clr_slice, int width, int height, int color_channels)
 {
     int i, j;
     float s;
@@ -369,12 +356,12 @@ int color_channels;
  */
 
 static void
-AlphaScaleColors(opc_slice, clr_slice, width, height, color_channels)
-float *opc_slice;	/* 2D array of opacities (width by height) */
-float *clr_slice;	/* 2D array of colors (width by height) */
-int width;		/* size of voxel slice */
-int height;
-int color_channels;	/* number of color channels in clr_slice */
+AlphaScaleColors(
+	float *opc_slice,	/* 2D array of opacities (width by height) */
+	float *clr_slice,	/* 2D array of colors (width by height) */
+	int width,		/* size of voxel slice */
+	int height,
+	int color_channels)	/* number of color channels in clr_slice */
 {
     int i, j;
 
@@ -400,16 +387,15 @@ int color_channels;	/* number of color c
  */
 
 static void
-DepthCueSlice(vpc, clr_slice, width, height, color_channels,
-	      depth_00k, depth_di, depth_dj)
-vpContext *vpc;
-float *clr_slice;
-int width;
-int height;
-int color_channels;
-double depth_00k;		/* depth of top-left voxel in slice */
-double depth_di, depth_dj;	/* change in depth for unit change in
-				   i/j directions */
+DepthCueSlice(
+	vpContext *vpc,
+	float *clr_slice,
+	int width,
+	int height,
+	int color_channels,
+	double depth_00k,		/* depth of top-left voxel in slice */
+	double depth_di, double depth_dj)	/* change in depth for unit change in
+					   	   i/j directions */
 {
     int i, j;
     double depth, depth_0jk, factor;
@@ -446,22 +432,20 @@ double depth_di, depth_dj;	/* change in
  */
 
 static void
-TranslateSlice(opc_slice, clr_slice, width, height,
-	       WgtTL_d, WgtBL_d, WgtTR_d, WgtBR_d,
-	       color_channels, resamp_opc_slice, resamp_clr_slice)
-float *opc_slice;	/* 2D array of opacities (width by height) */
-float *clr_slice;	/* 2D array of colors (width by height) */
-int width;		/* size of voxel slice */
-int height;
-double WgtTL_d;		/* resampling weights */
-double WgtBL_d;
-double WgtTR_d;
-double WgtBR_d;
-int color_channels;	/* number of color channels in clr_slice */
-float *resamp_opc_slice;/* 2D array for storing resampled opacities
-			   (width+1 by height+1) */
-float *resamp_clr_slice;/* 2D array for storing resampled colors
-			   (width+1 by height+1) */
+TranslateSlice(
+	float *opc_slice,	/* 2D array of opacities (width by height) */
+	float *clr_slice,	/* 2D array of colors (width by height) */
+	int width,		/* size of voxel slice */
+	int height,
+	double WgtTL_d,		/* resampling weights */
+	double WgtBL_d,
+	double WgtTR_d,
+	double WgtBR_d,
+	int color_channels,	/* number of color channels in clr_slice */
+	float *resamp_opc_slice,/* 2D array for storing resampled opacities
+				   (width+1 by height+1) */
+	float *resamp_clr_slice)/* 2D array for storing resampled colors
+				   (width+1 by height+1) */
 {
     int i, j;
     float WgtTL, WgtBL, WgtTR, WgtBR;
@@ -542,17 +526,16 @@ float *resamp_clr_slice;/* 2D array for
  */
 
 static void
-CompositeSlice(resamp_opc, resamp_clr, width, height, color_channels,
-	       int_image_ptr, int_image_width, min_opacity)
-float *resamp_opc;	/* array of resampled opacities (width by height) */
-float *resamp_clr;	/* array of resampled colors (width by height) */
-int width;		/* size of resampled voxel arrays */
-int height;
-int color_channels;	/* number of color channels */
-void *int_image_ptr;	/* pointer to intermediate image pixel corresponding
-			   to top-left resampled voxel */
-int int_image_width;	/* number of pixels in intermediate image scanline */
-double min_opacity;	/* low opacity threshold */
+CompositeSlice(
+	float *resamp_opc,	/* array of resampled opacities (width by height) */
+	float *resamp_clr,	/* array of resampled colors (width by height) */
+	int width,		/* size of resampled voxel arrays */
+	int height,
+	int color_channels,	/* number of color channels */
+	void *int_image_ptr,	/* pointer to intermediate image pixel corresponding
+			  	 to top-left resampled voxel */
+	int int_image_width,	/* number of pixels in intermediate image scanline */
+	double min_opacity)	/* low opacity threshold */
 {
     int i, j;
     float old_opc, old_r, old_g, old_b;
@@ -614,8 +597,7 @@ double min_opacity;	/* low opacity thres
  */
 
 static void
-AffineBruteForceWarp(vpc)
-vpContext *vpc;
+AffineBruteForceWarp(vpContext *vpc)
 {
     unsigned char *int_image;	/* pointer to start of intermediate image
 				   (GrayIntPixel or RGBIntPixel) */
@@ -832,11 +814,11 @@ vpContext *vpc;
 }
 
 #ifdef DEBUG
-StoreFloatImage(data, width, height, scale, filename)
-float *data;		/* array of input data */
-int width, height;	/* size of array */
-double scale;		/* factor for scaling pixel values */
-char *filename;		/* name of file to store result */
+StoreFloatImage(
+	float *data,		/* array of input data */
+	int width, int height,	/* size of array */
+	double scale,		/* factor for scaling pixel values */
+	char *filename)		/* name of file to store result */
 {
     unsigned char *image, *imptr;
     int i, j;
--- a/vp_renderA.c
+++ b/vp_renderA.c
@@ -91,11 +91,11 @@ extern int vpRunFragmentCount;
  * Render a classified volume with an affine viewing transformation.
  */
 
-void
-VPRenderAffine(vpc, algorithm, composite_func)
-vpContext *vpc;
-int algorithm;	/* USE_RLEVOLUME or USE_RAWVOLUME */
-void (*composite_func)(); /* function to do the compositing */
+vpResult
+VPRenderAffine(
+	vpContext *vpc,
+	int algorithm,	/* USE_RLEVOLUME or USE_RAWVOLUME */
+	VPCompositeFunc composite_func) /* function to do the compositing */
 {
     int icount;			/* voxels per voxel scanline */
     int jcount;			/* voxel scanlines per voxel slice */
@@ -697,8 +697,7 @@ void (*composite_func)(); /* function to
  */
 
 vpResult
-vpPrintRayPath(vpc)
-vpContext *vpc;
+vpPrintRayPath(vpContext *vpc)
 {
     int icount;			/* voxels per voxel scanline */
     int jcount;			/* voxel scanlines per voxel slice */
--- a/vp_octree.c
+++ b/vp_octree.c
@@ -61,10 +61,10 @@ static void ComputeOctreeMask ANSI_ARGS(
  */
 
 vpResult
-vpCreateMinMaxOctree(vpc, root_node_size, base_node_size)
-vpContext *vpc;
-int root_node_size;	/* ignored for now */
-int base_node_size;	/* controls level of detail of smallest nodes */
+vpCreateMinMaxOctree(
+	vpContext *vpc,
+	int root_node_size,	/* ignored for now */
+	int base_node_size)	/* controls level of detail of smallest nodes */
 {
     int max_dim, retcode, p, f;
     int field_size;
@@ -175,8 +175,7 @@ int base_node_size;	/* controls level of
  */
 
 vpResult
-vpDestroyMinMaxOctree(vpc)
-vpContext *vpc;
+vpDestroyMinMaxOctree(vpContext *vpc)
 {
     if (vpc->mm_octree != NULL) {
 	if (vpc->mm_octree->root != NULL) {
@@ -196,9 +195,7 @@ vpContext *vpc;
  */
 
 static void
-CreatePyramid(vpc, mm_pyramid)
-vpContext *vpc;
-void *mm_pyramid[VP_MAX_OCTREE_LEVELS];
+CreatePyramid(vpContext *vpc, void *mm_pyramid[VP_MAX_OCTREE_LEVELS])
 {
     int pyr_size;		/* size of pyramid in bytes */
     int level, pyr_levels;	/* current, total pyramid levels */
@@ -427,16 +424,15 @@ void *mm_pyramid[VP_MAX_OCTREE_LEVELS];
  */
 
 static void
-DescendPyramid(vpc, mm_pyramid, level, x, y, z, nodes_per_side,
-	       parent_node, octree_offset)
-vpContext *vpc;		/* context */
-void *mm_pyramid[VP_MAX_OCTREE_LEVELS];	/* min-max pyramid */
-int level;		/* current level */
-int x, y, z;		/* current node coordinates (in coordinate system
-			   of the current level) */
-int nodes_per_side;	/* # nodes at current level per side of volume */
-void *parent_node;	/* parent octree node (or NULL) */
-int *octree_offset;	/* bytes from root of octree to next free location */
+DescendPyramid(
+	vpContext *vpc,		/* context */
+	void *mm_pyramid[VP_MAX_OCTREE_LEVELS],	/* min-max pyramid */
+	int level,		/* current level */
+	int x, int y, int z,	/* current node coordinates (in coordinate system
+			   	of the current level) */
+	int nodes_per_side,	/* # nodes at current level per side of volume */
+	void *parent_node,	/* parent octree node (or NULL) */
+	int *octree_offset)	/* bytes from root of octree to next free location */
 {
     char *pyr_ptr;
     char *child_node;
@@ -551,8 +547,7 @@ int *octree_offset;	/* bytes from root o
  */
 
 void
-VPComputeSummedAreaTable(vpc)
-vpContext *vpc;
+VPComputeSummedAreaTable(vpContext *vpc)
 {
     /* use a special-case version for lower dimensions
        (faster since C optimizer does a better job) */
@@ -577,8 +572,7 @@ vpContext *vpc;
  */
 
 static void
-Compute1DSummedAreaTable(vpc)
-vpContext *vpc;
+Compute1DSummedAreaTable(vpContext *vpc)
 {
     int p0max, p0value;
     unsigned table_size;
@@ -617,8 +611,7 @@ vpContext *vpc;
  */
 
 static void
-Compute2DSummedAreaTable(vpc)
-vpContext *vpc;
+Compute2DSummedAreaTable(vpContext *vpc)
 {
     int p0max, p0value, p1max, p1value;
     unsigned table_size;
@@ -668,8 +661,7 @@ vpContext *vpc;
  */
 
 void
-VPClassifyOctree(vpc)
-vpContext *vpc;
+VPClassifyOctree(vpContext *vpc)
 {
     /* use a special-case version for lower dimensions
        (faster since C optimizer does a better job) */
@@ -696,8 +688,7 @@ vpContext *vpc;
  */
 
 static void
-ClassifyOctree1(vpc)
-vpContext *vpc;
+ClassifyOctree1(vpContext *vpc)
 {
     char *node_stack[VP_MAX_OCTREE_LEVELS]; /* stack of node addresses */
     int count_stack[VP_MAX_OCTREE_LEVELS];  /* stack of node child counts;
@@ -813,8 +804,7 @@ vpContext *vpc;
  */
 
 static void
-ClassifyOctree2(vpc)
-vpContext *vpc;
+ClassifyOctree2(vpContext *vpc)
 {
     char *node_stack[VP_MAX_OCTREE_LEVELS]; /* stack of node addresses */
     int count_stack[VP_MAX_OCTREE_LEVELS];  /* stack of node child counts;
@@ -948,11 +938,11 @@ vpContext *vpc;
  */
 
 void
-VPInitOctreeLevelStack(vpc, level_stack, axis, k)
-vpContext *vpc;
-MMOctreeLevel level_stack[VP_MAX_OCTREE_LEVELS];
-int axis;	/* principle viewing axis */
-int k;		/* current slice number */
+VPInitOctreeLevelStack(
+	vpContext *vpc,
+	MMOctreeLevel level_stack[VP_MAX_OCTREE_LEVELS],
+	int axis,	/* principle viewing axis */
+	int k)		/* current slice number */
 {
     int max_level, level, last_node_size;
     int child_octant, child_bytes_per_node;
@@ -1002,13 +992,13 @@ int k;		/* current slice number */
  */
 
 int
-VPComputeScanRuns(vpc, level_stack, run_lengths, axis, j, icount)
-vpContext *vpc;
-MMOctreeLevel level_stack[VP_MAX_OCTREE_LEVELS]; /* saved state */
-unsigned char *run_lengths; /* storage for run lengths */
-int axis;		/* principle viewing axis */
-int j;			/* scanline number */
-int icount;		/* scanline length */
+VPComputeScanRuns(
+	vpContext *vpc,
+	MMOctreeLevel level_stack[VP_MAX_OCTREE_LEVELS], /* saved state */
+	unsigned char *run_lengths, /* storage for run lengths */
+	int axis,		/* principle viewing axis */
+	int j,			/* scanline number */
+	int icount)		/* scanline length */
 {
     int octree_maxlevel;
     int level;
@@ -1177,11 +1167,11 @@ int icount;		/* scanline length */
  */
 
 vpResult
-vpOctreeMask(vpc, array, array_size, max_level)
-vpContext *vpc;		/* context */
-unsigned char *array;	/* array for result */
-int array_size;		/* size of array in bytes */
-int max_level;
+vpOctreeMask(
+	vpContext *vpc,		/* context */
+	unsigned char *array,	/* array for result */
+	int array_size,		/* size of array in bytes */
+	int max_level)
 {
     int c;
     unsigned char *aptr;
@@ -1210,16 +1200,15 @@ int max_level;
  */
 
 static void
-ComputeOctreeMask(vpc, level, xn, yn, zn, node_size, parent_node, array,
-		  max_level)
-vpContext *vpc;		/* context */
-int level;		/* current level */
-int xn, yn, zn;		/* current node coordinates (in coordinate system
-			   of the current level) */
-int node_size;		/* voxel per side of node at this level */
-void *parent_node;	/* parent octree node */
-unsigned char *array;	/* array for storing result */
-int max_level;		/* deepest level of the tree to visit */
+ComputeOctreeMask(
+	vpContext *vpc,		/* context */
+	int level,		/* current level */
+	int xn, int yn, int zn,	/* current node coordinates (in coordinate system
+				   of the current level) */
+	int node_size,		/* voxel per side of node at this level */
+	void *parent_node,	/* parent octree node */
+	unsigned char *array,	/* array for storing result */
+	int max_level)		/* deepest level of the tree to visit */
 {
     char *child_node, *octree_root;
     int child_bytes_per_node;
@@ -1307,12 +1296,12 @@ int max_level;		/* deepest level of the
  */
 
 int
-VPCheckRuns(vpc, run_lengths, axis, k, j)
-vpContext *vpc;
-unsigned char *run_lengths;/* run lengths */
-int axis;		/* principle viewing axis */
-int k;			/* slice number */
-int j;			/* scanline number */
+VPCheckRuns(
+	vpContext *vpc,
+	unsigned char *run_lengths,/* run lengths */
+	int axis,		/* principle viewing axis */
+	int k,			/* slice number */
+	int j)			/* scanline number */
 {
     char *voxel;
     int i;
@@ -1392,8 +1381,7 @@ int j;			/* scanline number */
  */
 
 void
-VPTestMinMaxOctree(vpc)
-vpContext *vpc;
+VPTestMinMaxOctree(vpContext *vpc)
 {
     int x, y, z;
     MMOctreeLevel level_stack[VP_MAX_OCTREE_LEVELS];
@@ -1547,18 +1535,17 @@ vpContext *vpc;
 #else
 
 int
-VPCheckRuns(vpc, run_lengths, axis, k, j)
-vpContext *vpc;
-unsigned char *run_lengths;/* run lengths */
-int axis;		/* principle viewing axis */
-int k;			/* slice number */
-int j;			/* scanline number */
+VPCheckRuns(
+	vpContext *vpc,
+	unsigned char *run_lengths,/* run lengths */
+	int axis,		/* principle viewing axis */
+	int k,			/* slice number */
+	int j)			/* scanline number */
 {
 }
 
 void
-VPTestMinMaxOctree(vpc)
-vpContext *vpc;
+VPTestMinMaxOctree(vpContext *vpc)
 {
 }
 
--- a/vp_check.c
+++ b/vp_check.c
@@ -54,8 +54,7 @@ static char *ErrorString[] = {
  */
 
 vpResult
-VPCheckVoxelFields(vpc)
-vpContext *vpc;
+VPCheckVoxelFields(vpContext *vpc)
 {
     int f;
     int size, offset;
@@ -84,8 +83,7 @@ vpContext *vpc;
  */
 
 vpResult
-VPCheckRawVolume(vpc)
-vpContext *vpc;
+VPCheckRawVolume(vpContext *vpc)
 {
     int size, offset, retcode;
 
@@ -108,9 +106,7 @@ vpContext *vpc;
  */
 
 vpResult
-VPCheckClassifiedVolume(vpc, axis)
-vpContext *vpc;
-int axis;
+VPCheckClassifiedVolume(vpContext *vpc, int axis)
 {
     int retcode;
 
@@ -155,8 +151,7 @@ int axis;
  */
 
 vpResult
-VPCheckClassifier(vpc)
-vpContext *vpc;
+VPCheckClassifier(vpContext *vpc)
 {
     int p, f;
     int size, offset, retcode;
@@ -189,8 +184,7 @@ vpContext *vpc;
  */
 
 vpResult
-VPCheckShader(vpc)
-vpContext *vpc;
+VPCheckShader(vpContext *vpc)
 {
     if (vpc->shading_mode == LOOKUP_SHADER) {
 	if (vpc->color_field < 0 ||
@@ -231,8 +225,7 @@ vpContext *vpc;
  */
 
 vpResult
-VPCheckImage(vpc)
-vpContext *vpc;
+VPCheckImage(vpContext *vpc)
 {
     if (vpc->image == NULL || vpc->image_width <= 0 || vpc->image_height <= 0)
 	return(VPSetError(vpc, VPERROR_BAD_IMAGE));
@@ -264,8 +257,7 @@ vpContext *vpc;
  */
 
 vpResult
-VPCheckShadows(vpc)
-vpContext *vpc;
+VPCheckShadows(vpContext *vpc)
 {
     if (vpc->enable_shadows) {
 	if (vpc->shadow_light_num < VP_LIGHT0 ||
@@ -288,8 +280,7 @@ vpContext *vpc;
  */
 
 vpResult
-vpGetError(vpc)
-vpContext *vpc;
+vpGetError(vpContext *vpc)
 {
     vpResult code;
 
@@ -305,8 +296,7 @@ vpContext *vpc;
  */
 
 char *
-vpGetErrorString(code)
-vpResult code;
+vpGetErrorString(vpResult code)
 {
     if (code == VP_OK)
 	return("no error");
@@ -323,9 +313,7 @@ vpResult code;
  */
 
 vpResult
-VPSetError(vpc, code)
-vpContext *vpc;
-vpResult code;
+VPSetError(vpContext *vpc, vpResult code)
 {
     if (vpc->error_code == VP_OK)
 	vpc->error_code = code;
--- a/vp_file.c
+++ b/vp_file.c
@@ -108,9 +108,9 @@ typedef struct {
  */
 
 vpResult
-vpStoreClassifiedVolume(vpc, fd)
-vpContext *vpc;	/* context containing the volume */
-int fd;		/* UNIX file descriptor open for writing */
+vpStoreClassifiedVolume(
+	vpContext *vpc,	/* context containing the volume */
+	int fd)		/* UNIX file descriptor open for writing */
 {
     RLEVoxelHdr header;
     unsigned field_data[3*VP_MAX_FIELDS];
@@ -211,10 +211,10 @@ int fd;		/* UNIX file descriptor open fo
  */
 
 static int
-StoreRLEVoxels(vpc, fd, rle_voxels)
-vpContext *vpc;
-int fd;
-RLEVoxels *rle_voxels;
+StoreRLEVoxels(
+	vpContext *vpc,
+	int fd,
+	RLEVoxels *rle_voxels)
 {
     int size;
     char pad_data[8];
@@ -265,9 +265,9 @@ RLEVoxels *rle_voxels;
  */
 
 vpResult
-vpLoadClassifiedVolume(vpc, fd)
-vpContext *vpc;	/* context to store the volume into */
-int fd;		/* UNIX file descriptor open for reading */
+vpLoadClassifiedVolume(
+	vpContext *vpc,	/* context to store the volume into */
+	int fd)		/* UNIX file descriptor open for reading */
 {
     RLEVoxelHdr header;
     unsigned field_data[3*VP_MAX_FIELDS];
@@ -488,12 +488,12 @@ int fd;		/* UNIX file descriptor open fo
  */
 
 static int
-LoadRLEVoxels(vpc, fd, rle_voxels, offsets, swab)
-vpContext *vpc;
-int fd;
-RLEVoxels *rle_voxels;
-int offsets;
-int swab;
+LoadRLEVoxels(
+	vpContext *vpc,
+	int fd,
+	RLEVoxels *rle_voxels,
+	int offsets,
+	int swab)
 {
     int size;
     char pad_data[8];
@@ -550,9 +550,7 @@ int swab;
  */
 
 static void
-SwapWords(data, size)
-void *data;
-unsigned size;
+SwapWords(void *data, unsigned size)
 {
     unsigned char *ptr;
     int tmp1, tmp2;
@@ -573,12 +571,12 @@ unsigned size;
  */
 
 static void
-SwapVoxels(vpc, voxels, num_voxels, fields, bytes_per_voxel)
-vpContext *vpc;		/* context */
-void *voxels;		/* array of voxels */
-int num_voxels;		/* number of voxels in the array */
-int fields;		/* number of fields in voxel */
-int bytes_per_voxel;	/* size of voxel in bytes */
+SwapVoxels(
+	vpContext *vpc,		/* context */
+	void *voxels,		/* array of voxels */
+	int num_voxels,		/* number of voxels in the array */
+	int fields,		/* number of fields in voxel */
+	int bytes_per_voxel)	/* size of voxel in bytes */
 {
     int f, size, offset;
     unsigned char *voxel_ptr;
@@ -656,9 +654,9 @@ typedef struct {
  */
 
 vpResult
-vpStoreMinMaxOctree(vpc, fd)
-vpContext *vpc;	/* context containing the octree */
-int fd;		/* UNIX file descriptor open for writing */
+vpStoreMinMaxOctree(
+	vpContext *vpc,	/* context containing the octree */
+	int fd)		/* UNIX file descriptor open for writing */
 {
     MinMaxOctreeHdr header;
     unsigned field_data[3*VP_MAX_FIELDS];
@@ -713,9 +711,9 @@ int fd;		/* UNIX file descriptor open fo
  */
 
 vpResult
-vpLoadMinMaxOctree(vpc, fd)
-vpContext *vpc;	/* context to store the octree into */
-int fd;		/* UNIX file descriptor open for reading */
+vpLoadMinMaxOctree(
+	vpContext *vpc,	/* context to store the octree into */
+	int fd)		/* UNIX file descriptor open for reading */
 {
     MinMaxOctreeHdr header;
     unsigned field_data[3*VP_MAX_FIELDS];
@@ -793,10 +791,7 @@ int fd;		/* UNIX file descriptor open fo
  */
 
 static void
-SwapOctreeNode(vpc, level, node)
-vpContext *vpc;
-int level;
-void *node;
+SwapOctreeNode(vpContext *vpc, int level, void *node)
 {
     int p, field, size, offset, tmp1, tmp2;
     int child_bytes_per_node;
@@ -887,9 +882,9 @@ typedef struct {
  */
 
 vpResult
-vpStoreRawVolume(vpc, fd)
-vpContext *vpc;	/* context containing the volume */
-int fd;		/* UNIX file descriptor open for writing */
+vpStoreRawVolume(
+	vpContext *vpc,	/* context containing the volume */
+	int fd)		/* UNIX file descriptor open for writing */
 {
     RawVoxelHdr header;
     unsigned field_data[3*VP_MAX_FIELDS];
@@ -942,9 +937,9 @@ int fd;		/* UNIX file descriptor open fo
  */
 
 vpResult
-vpLoadRawVolume(vpc, fd)
-vpContext *vpc;	/* context to store the volume into */
-int fd;		/* UNIX file descriptor open for reading */
+vpLoadRawVolume(
+	vpContext *vpc,	/* context to store the volume into */
+	int fd)		/* UNIX file descriptor open for reading */
 {
     RawVoxelHdr header;
     unsigned field_data[3*VP_MAX_FIELDS];
@@ -1054,9 +1049,7 @@ typedef struct {
  */
 
 vpResult
-vpStoreContext(vpc, fd)
-vpContext *vpc;
-int fd;
+vpStoreContext(vpContext *vpc, int fd)
 {
     VpcHdr header;
     int i;
@@ -1095,11 +1088,7 @@ int fd;
  */
 
 static int
-StoreTable(vpc, fd, ptr, size)
-vpContext *vpc;
-int fd;
-float *ptr;
-unsigned size;
+StoreTable(vpContext *vpc, int fd, float *ptr, unsigned size)
 {
     if (size == 0 || ptr == NULL) {
 	size = 0;
@@ -1128,9 +1117,7 @@ unsigned size;
  */
 
 vpResult
-vpLoadContext(vpc, fd)
-vpContext *vpc;
-int fd;
+vpLoadContext(vpContext *vpc, int fd)
 {
     VpcHdr header;
     int swab, i;
@@ -1205,11 +1192,11 @@ int fd;
  */
 
 static int
-LoadTable(vpc, fd, ptr_ptr, size_ptr)
-vpContext *vpc;
-int fd;
-float **ptr_ptr;
-unsigned *size_ptr;
+LoadTable(
+	vpContext *vpc,
+	int fd,
+	float **ptr_ptr,
+	unsigned *size_ptr)
 {
     if (vpc->read_func(fd, size_ptr, sizeof(unsigned)) != sizeof(unsigned))
 	return(0);
--- a/volpack.h
+++ b/volpack.h
@@ -368,8 +368,8 @@ EXTERN vpResult		    vpSetVoxelField ANS
 				int field_num, int field_size,
 				int field_offset, int field_max));
 EXTERN vpResult		    vpSetRawVoxels ANSI_ARGS((vpContext *vpc,
-				void *raw_voxels, int raw_voxels_size,
-				int xstride, int ystride, int zstride));
+				int xstride, int ystride, int zstride,
+				void *raw_voxels, int raw_voxels_size));
 
 /* classification */
 EXTERN vpResult		    vpSetClassifierTable ANSI_ARGS((vpContext *vpc,
